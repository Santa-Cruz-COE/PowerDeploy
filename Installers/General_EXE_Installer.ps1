# General EXE Installer
# For use with PowerDeploy suite
# NOTE: This script was originally generated by Claude Opus 4.5 but has been manually reviewed and edited and tested
# SOURCE: https://github.com/Santa-Cruz-COE/PowerDeploy

<#
.SYNOPSIS
    Installs EXE packages with configurable arguments, timeout handling, and installation verification.

.DESCRIPTION
    This script provides a standardized way to install EXE-based applications with comprehensive logging,
    error handling, timeout protection, and post-install verification. It supports common silent install
    argument patterns and verifies installation via registry checks.

    Features:
    - Silent/quiet installation with customizable arguments
    - Timeout protection with configurable duration
    - Pre-installation check to avoid reinstalling existing apps
    - Post-installation verification via registry
    - Comprehensive logging with color-coded output
    - Support for common installer frameworks (InstallShield, Inno Setup, NSIS, etc.)

.PARAMETER EXEPath
    Full path to the EXE file to install.
    The file must exist and have a .exe extension.

.PARAMETER AppName
    Friendly name of the application being installed (used for logging).
    Example: "Adobe_Reader"

.PARAMETER DisplayName
    The display name of the application as it appears in Add/Remove Programs.
    Used for post-install verification. Supports wildcard matching.
    If not provided, verification step will be skipped.
    Example: "Adobe Acrobat Reader" (will match "Adobe Acrobat Reader DC", etc.)

.PARAMETER WorkingDirectory
    Path to directory on the host machine that will be used to hold logs.
    Recommended: "C:\ProgramData\PowerDeploy"

.PARAMETER ArgumentList
    Custom EXE installation arguments for silent install.
    If not provided, the script will attempt to detect the installer type and use appropriate defaults.
    
    Common silent install arguments by installer type:
    - InstallShield: /s /v"/qn"
    - Inno Setup: /VERYSILENT /SUPPRESSMSGBOXES /NORESTART
    - NSIS: /S
    - WiX Burn: /quiet /norestart
    - Generic: /silent /quiet /S /s
    
    Example: "/VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-"

.PARAMETER TimeoutSeconds
    Maximum time in seconds to wait for installation to complete.
    Default: 900 (15 minutes)

.PARAMETER SkipVerification
    If specified, skips the post-install verification check.
    Default: $false

.PARAMETER ExpectedExitCodes
    Array of exit codes that should be considered successful.
    Default: @(0, 3010) where 3010 indicates success but restart required.

.PARAMETER WaitForProcess
    If specified, waits for child processes spawned by the installer to complete.
    Useful for installers that spawn separate processes and exit immediately.
    Default: $false

.EXAMPLE
    .\General_EXE_Installer.ps1 -EXEPath "C:\Temp\Downloads\app_setup.exe" -AppName "MyApp" -DisplayName "My Application" -WorkingDirectory "C:\ProgramData\PowerDeploy"
    Installs app_setup.exe with auto-detected silent arguments and verification

.EXAMPLE
    .\General_EXE_Installer.ps1 -EXEPath "C:\Temp\Downloads\setup.exe" -AppName "CustomApp" -DisplayName "Custom Application" -WorkingDirectory "C:\ProgramData\PowerDeploy" -ArgumentList "/VERYSILENT /NORESTART"
    Installs with custom Inno Setup arguments

.EXAMPLE
    .\General_EXE_Installer.ps1 -EXEPath "C:\Temp\Downloads\installer.exe" -AppName "SomeApp" -WorkingDirectory "C:\ProgramData\PowerDeploy" -SkipVerification
    Installs without post-install verification

.EXAMPLE
    .\General_EXE_Installer.ps1 -EXEPath "C:\Temp\setup.exe" -AppName "LargeApp" -DisplayName "Large Application" -WorkingDirectory "C:\ProgramData\PowerDeploy" -TimeoutSeconds 1800 -WaitForProcess
    Installs with 30-minute timeout and waits for child processes

.NOTES
    SOURCE: https://github.com/Santa-Cruz-COE/PowerDeploy
    
    Common EXE Installer Exit Codes:
    0    - Success
    1    - General error
    2    - Invalid command line
    3    - Installation incomplete
    1601 - Windows Installer not accessible
    1602 - User cancelled installation
    1603 - Fatal error during installation
    1618 - Another installation already in progress
    3010 - Success, restart required
    
    Installer Type Detection:
    The script attempts to detect the installer framework by examining the EXE properties
    and uses appropriate default silent arguments. Manual override is recommended for
    best results.
#>

Param(
    [Parameter(Mandatory=$true)]
    [String]$EXEPath,

    [Parameter(Mandatory=$true)]
    [String]$AppName,

    [Parameter(Mandatory=$false)]
    [String]$DisplayName = $null,

    [Parameter(Mandatory=$true)]
    [String]$WorkingDirectory,

    [Parameter(Mandatory=$false)]
    [String]$ArgumentList = $null,

    [Parameter(Mandatory=$false)]
    [int]$TimeoutSeconds = 900,

    [Parameter(Mandatory=$false)]
    [switch]$SkipVerification = $false,

    [Parameter(Mandatory=$false)]
    [int[]]$ExpectedExitCodes = @(0, 3010),

    [Parameter(Mandatory=$false)]
    [switch]$WaitForProcess = $false
)

############
### Vars ###
############

$ThisFileName = $MyInvocation.MyCommand.Name
$ScriptRoot = $PSScriptRoot
$RepoRoot = Split-Path $ScriptRoot -Parent

$LogRoot = "$WorkingDirectory\Logs\Installer_Logs"
$SafeAppName = $AppName -replace '[^\w]', '_'
$LogPath = "$LogRoot\$SafeAppName.EXE_Installer_Log_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"

$DetectionScript = "$RepoRoot\Templates\Detection-Script-Application_TEMPLATE.ps1"

$InstallSuccess = $false

#################
### Functions ###
#################

# NOTE: This function will not use write-log.
function Test-PathSyntaxValidity {
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$Paths,
        [switch]$ExitOnError
    )
    
    # Windows illegal path characters (excluding : for drive letters and \ for path separators)
    $illegalChars = '[<>"|?*]'
    
    # Reserved Windows filenames
    $reservedNames = @(
        'CON', 'PRN', 'AUX', 'NUL',
        'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9',
        'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9'
    )
    
    $allValid = $true
    $issues = @()
    
    foreach ($paramName in $Paths.Keys) {
        $path = $Paths[$paramName]
        
        # Skip if null or empty
        if ([string]::IsNullOrWhiteSpace($path)) {
            $issues += "Parameter '$paramName' is null or empty"
            $allValid = $false
            continue
        }
        
        # Check for trailing backslash before closing quote pattern (common BAT file issue)
        if ($path -match '\\["\' + "']$") {
            $issues += "Parameter '$paramName' has trailing backslash before quote: '$path' - This will cause escape character issues"
            $allValid = $false
        }
        
        # Check for illegal characters
        if ($path -match $illegalChars) {
            $matches = [regex]::Matches($path, $illegalChars)
            $foundChars = ($matches | ForEach-Object { $_.Value }) -join ', '
            $issues += "Parameter '$paramName' contains illegal characters ($foundChars): '$path'"
            $allValid = $false
        }
        
        # Check for invalid double backslashes (except at start for UNC paths)
        if ($path -match '(?<!^)\\\\') {
            $issues += "Parameter '$paramName' contains invalid double backslashes: '$path'"
            $allValid = $false
        }
        
        # Check path segments for reserved names
        $segments = $path -split '[\\/]' | Where-Object { $_ }
        foreach ($segment in $segments) {
            $nameWithoutExt = [System.IO.Path]::GetFileNameWithoutExtension($segment)
            if ($reservedNames -contains $nameWithoutExt.ToUpper()) {
                $issues += "Parameter '$paramName' contains reserved filename '$segment': '$path'"
                $allValid = $false
            }
        }
    }
    
    # Report results
    if (-not $allValid) {
        Write-Host "XXXXXXXXXXXXXXXXXXXXXXXXXXXX Path Syntax Validation FAILED:" -ForegroundColor Red
        foreach ($issue in $issues) {
            Write-Host "XXXXXXXXXXXXXXXXXXXXXXXXXXXX   - $issue" -ForegroundColor Red
        }
        
        if ($ExitOnError) {
            Write-Host "XXXXXXXXXXXXXXXXXXXXXXXXXXXX Exiting due to path validation errors." -ForegroundColor Red
            Exit 1
        }
    } else {
        Write-Host "XXXXXXXXXXXXXXXXXXXXXXXXXXXX Path Syntax Validation PASSED" -ForegroundColor Green
    }
    
    return $allValid
}

function Write-Log {
    param(
        [string]$Message,
        [string]$Level = "INFO"
    )
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Level] $Message"
    
    switch ($Level) {
        "ERROR"   { Write-Host $logEntry -ForegroundColor Red }
        "WARNING" { Write-Host $logEntry -ForegroundColor Yellow }
        "SUCCESS" { Write-Host $logEntry -ForegroundColor Green }
        "DRYRUN"  { Write-Host $logEntry -ForegroundColor Cyan }
        "INFO2"   { Write-Host $logEntry -ForegroundColor DarkGray }
        default   { Write-Host $logEntry }
    }
    
    # Ensure log directory exists
    $logDir = Split-Path $LogPath -Parent
    if (!(Test-Path $logDir)) {
        New-Item -ItemType Directory -Path $logDir -Force | Out-Null
    }
    
    Add-Content -Path $LogPath -Value $logEntry
}

function Test-EXEFile {
    param(
        [string]$Path
    )
    
    Write-Log "-----------------------------------------"
    Write-Log "Function: Test-EXEFile | Begin"
    Write-Log "Validating EXE file: $Path"
    
    # Check if file exists
    if (-not (Test-Path -Path $Path -PathType Leaf)) {
        Write-Log "EXE file not found: $Path" "ERROR"
        Write-Log "Function: Test-EXEFile | End | FAILED"
        Write-Log "-----------------------------------------"
        return $false
    }
    
    # Check file extension
    $extension = [System.IO.Path]::GetExtension($Path)
    if ($extension -ne '.exe') {
        Write-Log "File is not an EXE: $Path (extension: $extension)" "ERROR"
        Write-Log "Function: Test-EXEFile | End | FAILED"
        Write-Log "-----------------------------------------"
        return $false
    }
    
    # Check file size (should be > 0)
    $fileInfo = Get-Item -Path $Path
    if ($fileInfo.Length -eq 0) {
        Write-Log "EXE file is empty (0 bytes): $Path" "ERROR"
        Write-Log "Function: Test-EXEFile | End | FAILED"
        Write-Log "-----------------------------------------"
        return $false
    }
    
    Write-Log "EXE file validated successfully"
    Write-Log "  File size: $([math]::Round($fileInfo.Length / 1MB, 2)) MB"
    Write-Log "Function: Test-EXEFile | End | SUCCESS"
    Write-Log "-----------------------------------------"
    return $true
}

function Get-InstallerType {
    param(
        [string]$EXEPath
    )
    
    Write-Log "-----------------------------------------"
    Write-Log "Function: Get-InstallerType | Begin"
    Write-Log "Attempting to detect installer type for: $EXEPath"
    
    $installerType = "Unknown"
    
    try {
        # Get file version info
        $versionInfo = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($EXEPath)
        
        $productName = $versionInfo.ProductName
        $companyName = $versionInfo.CompanyName
        $fileDescription = $versionInfo.FileDescription
        $internalName = $versionInfo.InternalName
        
        Write-Log "File Properties:"
        Write-Log "  Product Name: $productName"
        Write-Log "  Company Name: $companyName"
        Write-Log "  File Description: $fileDescription"
        Write-Log "  Internal Name: $internalName"
        
        # Detect installer type based on properties
        if ($fileDescription -like "*Inno Setup*" -or $internalName -like "*Inno*") {
            $installerType = "InnoSetup"
        }
        elseif ($fileDescription -like "*Nullsoft*" -or $productName -like "*NSIS*") {
            $installerType = "NSIS"
        }
        elseif ($companyName -like "*InstallShield*" -or $fileDescription -like "*InstallShield*") {
            $installerType = "InstallShield"
        }
        elseif ($productName -like "*WiX*" -or $fileDescription -like "*WiX*" -or $internalName -like "*burn*") {
            $installerType = "WiXBurn"
        }
        elseif ($fileDescription -like "*Setup Factory*") {
            $installerType = "SetupFactory"
        }
        elseif ($fileDescription -like "*Advanced Installer*") {
            $installerType = "AdvancedInstaller"
        }
        else {
            # Try reading first bytes of file to detect packer
            $bytes = [System.IO.File]::ReadAllBytes($EXEPath) | Select-Object -First 1024
            $bytesString = [System.Text.Encoding]::ASCII.GetString($bytes)
            
            if ($bytesString -like "*Inno Setup*") {
                $installerType = "InnoSetup"
            }
            elseif ($bytesString -like "*Nullsoft*") {
                $installerType = "NSIS"
            }
        }
        
        Write-Log "Detected installer type: $installerType"
        
    }
    catch {
        Write-Log "Could not determine installer type: $_" "WARNING"
    }
    
    Write-Log "Function: Get-InstallerType | End"
    Write-Log "-----------------------------------------"
    
    return $installerType
}

function Get-DefaultSilentArguments {
    param(
        [string]$InstallerType
    )
    
    Write-Log "-----------------------------------------"
    Write-Log "Function: Get-DefaultSilentArguments | Begin"
    Write-Log "Getting default silent arguments for installer type: $InstallerType"
    
    $args = switch ($InstallerType) {
        "InnoSetup"        { "/VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-" }
        "NSIS"             { "/S" }
        "InstallShield"    { "/s /v`"/qn /norestart`"" }
        "WiXBurn"          { "/quiet /norestart" }
        "SetupFactory"     { "/S" }
        "AdvancedInstaller" { "/i /qn" }
        default            { "/S /silent /quiet" }  # Generic fallback - try common silent switches
    }
    
    Write-Log "Default arguments: $args"
    Write-Log "Function: Get-DefaultSilentArguments | End"
    Write-Log "-----------------------------------------"
    
    return $args
}

function Install-EXEPackage {
    param(
        [string]$EXEPath,
        [string]$Arguments,
        [int]$Timeout,
        [int[]]$SuccessExitCodes,
        [bool]$WaitForChildren
    )
    
    Write-Log "-----------------------------------------"
    Write-Log "Function: Install-EXEPackage | Begin"
    Write-Log "Installing: $EXEPath"
    
    # Create log file paths for EXE installation
    $EXEOutputLog = "$LogRoot\$SafeAppName.EXE_InstallationOutput_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
    $EXEErrorLog = "$LogRoot\$SafeAppName.EXE_InstallationError_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
    
    Write-Log "EXE Output Log: $EXEOutputLog"
    Write-Log "EXE Error Log: $EXEErrorLog"
    Write-Log "Installation command: `"$EXEPath`" $Arguments"
    Write-Log "Timeout: $Timeout seconds"
    Write-Log "Expected success exit codes: $($SuccessExitCodes -join ', ')"
    
    try {
        # Start the installation process
        $procParams = @{
            FilePath = $EXEPath
            WindowStyle = 'Hidden'
            PassThru = $true
            RedirectStandardOutput = $EXEOutputLog
            RedirectStandardError = $EXEErrorLog
        }
        
        # Only add ArgumentList if we have arguments
        if (-not [string]::IsNullOrWhiteSpace($Arguments)) {
            $procParams['ArgumentList'] = $Arguments
        }
        
        Write-Log "Starting EXE installation process..."
        $proc = Start-Process @procParams
        
        $processId = $proc.Id
        Write-Log "Process started with PID: $processId"
        
        # Monitor process with timeout
        $startTime = Get-Date
        
        while (-not $proc.HasExited) {
            Start-Sleep -Seconds 10
            $elapsed = (Get-Date) - $startTime
            Write-Log "Time elapsed: $([math]::Round($elapsed.TotalSeconds, 0)) / $Timeout seconds" "INFO2"
            
            if ($elapsed.TotalSeconds -ge $Timeout) {
                Write-Log "Timeout reached ($Timeout seconds) for $AppName. Killing process..." "WARNING"
                try {
                    $proc.Kill()
                    Write-Log "Process killed due to timeout for $AppName" "ERROR"
                }
                catch {
                    Write-Log "Failed to kill process: $_" "ERROR"
                }
                
                Write-Log "Function: Install-EXEPackage | End | TIMEOUT"
                Write-Log "-----------------------------------------"
                return $false
            }
        }
        
        $exitCode = $proc.ExitCode
        Write-Log "Process exited with code: $exitCode"
        
        # Wait for child processes if requested
        if ($WaitForChildren) {
            Write-Log "Waiting for child processes to complete..."
            Start-Sleep -Seconds 10
            
            # Try to find and wait for common installer child processes
            $childProcessNames = @("msiexec", "setup", "install", $SafeAppName)
            foreach ($procName in $childProcessNames) {
                $childProcs = Get-Process -Name $procName -ErrorAction SilentlyContinue
                if ($childProcs) {
                    Write-Log "Found running child process: $procName - waiting for completion..."
                    $childProcs | ForEach-Object {
                        try {
                            $_ | Wait-Process -Timeout 300 -ErrorAction SilentlyContinue
                        }
                        catch {
                            Write-Log "Timeout waiting for child process $procName" "WARNING"
                        }
                    }
                }
            }
        }
        
        # Log output and error files content
        if (Test-Path $EXEOutputLog) {
            $outputContent = Get-Content $EXEOutputLog -Raw -ErrorAction SilentlyContinue
            if ($outputContent) {
                Write-Log "Installation Output:"
                $outputContent -split "`n" | ForEach-Object { Write-Log "  OUTPUT: $_" "INFO2" }
            }
        }
        
        if (Test-Path $EXEErrorLog) {
            $errorContent = Get-Content $EXEErrorLog -Raw -ErrorAction SilentlyContinue
            if ($errorContent) {
                Write-Log "Installation Errors:"
                $errorContent -split "`n" | ForEach-Object { Write-Log "  ERROR: $_" "WARNING" }
            }
        }
        
        # Check if exit code is in the list of expected success codes
        if ($SuccessExitCodes -contains $exitCode) {
            Write-Log "Exit code $exitCode is in expected success codes" "SUCCESS"
            
            if ($exitCode -eq 3010) {
                Write-Log "Note: Exit code 3010 indicates a restart is required to complete installation" "WARNING"
            }
            
            $result = $true
        }
        else {
            Write-Log "Exit code $exitCode is NOT in expected success codes ($($SuccessExitCodes -join ', '))" "WARNING"
            
            # Provide helpful information based on common exit codes
            switch ($exitCode) {
                1   { Write-Log "Exit code 1: General error - check logs for details" "WARNING" }
                2   { Write-Log "Exit code 2: Invalid command line arguments" "WARNING" }
                1602 { Write-Log "Exit code 1602: User cancelled installation" "WARNING" }
                1603 { Write-Log "Exit code 1603: Fatal error during installation" "ERROR" }
                1618 { Write-Log "Exit code 1618: Another installation is in progress" "WARNING" }
                5   { Write-Log "Exit code 5: Access denied - may need elevated privileges" "ERROR" }
                default { Write-Log "Exit code $exitCode : Unknown error. Check installer documentation." "WARNING" }
            }
            
            $result = $false
        }
        
        # Wait for file system to update
        Write-Log "Waiting for system to update..."
        Start-Sleep -Seconds 5
        
        Write-Log "Function: Install-EXEPackage | End"
        Write-Log "-----------------------------------------"

        return $result
        
    }
    catch {
        Write-Log "Function: Install-EXEPackage | Exception occurred: $_" "ERROR"
        Write-Log "Function: Install-EXEPackage | End"
        Write-Log "-----------------------------------------"
        return $false
    }
}

############
### MAIN ###
############

## Pre-Check
Write-Host "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
Write-Host "XXXXXXXXXXXXXXXXXXXXXXXXXXXX PRE-CHECK for SCRIPT: $ThisFileName"
Write-Host "XXXXXXXXXXXXXXXXXXXXXXXXXXXX NOTE: PRE-CHECK is not logged"
Write-Host "XXXXXXXXXXXXXXXXXXXXXXXXXXXX Checking if supplied paths are valid"

# Test the paths
$pathsToValidate = @{
    'EXEPath' = $EXEPath
    'WorkingDirectory' = $WorkingDirectory
    'LogRoot' = $LogRoot
    'LogPath' = $LogPath
}

Test-PathSyntaxValidity -Paths $pathsToValidate -ExitOnError

Write-Host "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"

## Begin main body
Write-Log "===== EXE Installer Script Started ====="
Write-Log "AppName: $AppName"
Write-Log "EXE Path: $EXEPath"
Write-Log "WorkingDirectory: $WorkingDirectory"
Write-Log "Timeout: $TimeoutSeconds seconds"
Write-Log "Expected Exit Codes: $($ExpectedExitCodes -join ', ')"
Write-Log "Wait for Child Processes: $WaitForProcess"

if ($DisplayName) {
    Write-Log "Display Name (for verification): $DisplayName"
} else {
    Write-Log "Display Name: Not provided - verification will be skipped"
}

if ($SkipVerification) {
    Write-Log "Skip Verification: TRUE"
}

if ($ArgumentList) {
    Write-Log "Custom Arguments: $ArgumentList"
} else {
    Write-Log "Arguments: Will auto-detect based on installer type"
}
Write-Log "==========================================="

## Check for pre-existing installation
if ($DisplayName -and -not $SkipVerification) {
    Write-Log "Checking for pre-existing installation..."
    
    Try {
        $preInstallCheck = $false
        
        if (Test-Path $DetectionScript) {
            & $DetectionScript -DisplayName $DisplayName -DetectMethod "MSI_Registry" -WorkingDirectory $WorkingDirectory
            if ($LASTEXITCODE -eq 0) {
                $preInstallCheck = $true
            } else {
                $preInstallCheck = $false
            }
        } else {
            Write-Log "Detection script not found at: $DetectionScript - using built-in check" "WARNING"
            
            # Fallback: Check registry directly
            $registryPaths = @(
                'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*',
                'HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*'
            )
            
            $installedApp = Get-ItemProperty -Path $registryPaths -ErrorAction SilentlyContinue | 
                            Where-Object { $_.DisplayName -like "*$DisplayName*" } | 
                            Select-Object -First 1
            
            if ($installedApp) {
                $preInstallCheck = $true
            }
        }
    }
    catch {
        Write-Log "Error during pre-install check: $_" "WARNING"
        $preInstallCheck = $false
    }

    if ($preInstallCheck) {
        Write-Log "Application '$DisplayName' is already installed!" "SUCCESS"
        Write-Log "SCRIPT: $ThisFileName | END | Application already present, no installation needed" "SUCCESS"
        Exit 0
    } else {
        Write-Log "No pre-existing installation detected, proceeding with installation"
    }
}

## Validate EXE file
Write-Log "Validating EXE file..."
if (-not (Test-EXEFile -Path $EXEPath)) {
    Write-Log "SCRIPT: $ThisFileName | END | EXE file validation failed" "ERROR"
    Exit 1
}

## Determine installation arguments
if ([string]::IsNullOrWhiteSpace($ArgumentList)) {
    Write-Log "No custom arguments provided - Attempting to create custom arguments based on installer type..."
    $installerType = Get-InstallerType -EXEPath $EXEPath
    $ArgumentList = Get-DefaultSilentArguments -InstallerType $installerType
    Write-Log "Using auto-detected arguments: $ArgumentList"
} else {
    Write-Log "Using provided custom arguments: $ArgumentList"
}

## Perform installation
Write-Log "Beginning EXE installation for: $AppName"

$InstallSuccess = Install-EXEPackage -EXEPath $EXEPath -Arguments $ArgumentList -Timeout $TimeoutSeconds -SuccessExitCodes $ExpectedExitCodes -WaitForChildren $WaitForProcess

## Post-install verification
if ($DisplayName -and -not $SkipVerification) {
    Write-Log "========================================="
    Write-Log "Performing post-install verification..."
    
    # Give system extra time to register the installation
    Write-Log "Waiting for system to register installation..."
    Start-Sleep -Seconds 10
    
    # Try verification up to 3 times with delays
    $maxAttempts = 3
    $verified = $false
    
    for ($attempt = 1; $attempt -le $maxAttempts; $attempt++) {
        Write-Log "Verification attempt $attempt of $maxAttempts"
        
        Try {
            if (Test-Path $DetectionScript) {
                & $DetectionScript -DisplayName $DisplayName -DetectMethod "MSI_Registry" -WorkingDirectory $WorkingDirectory
                if ($LASTEXITCODE -eq 0) {
                    $verified = $true
                } else {
                    $verified = $false
                }
            } else {
                # Fallback: Check registry directly
                $registryPaths = @(
                    'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*',
                    'HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*'
                )
                
                $installedApp = Get-ItemProperty -Path $registryPaths -ErrorAction SilentlyContinue | 
                                Where-Object { $_.DisplayName -like "*$DisplayName*" } | 
                                Select-Object -First 1
                
                if ($installedApp) {
                    $verified = $true
                    Write-Log "Found: $($installedApp.DisplayName)" "SUCCESS"
                }
            }
        }
        catch {
            Write-Log "Error during verification: $_" "WARNING"
            $verified = $false
        }

        if ($verified) {
            Write-Log "Post-install verification successful!" "SUCCESS"
            $InstallSuccess = $True
            break
        } else {
            if ($attempt -lt $maxAttempts) {
                Write-Log "Verification failed, waiting 5 seconds before retry..." "WARNING"
                Start-Sleep -Seconds 5
            }
        }
    }
    
    if (-not $verified) {
        Write-Log "Post-install verification failed - application not found in registry" "ERROR"
        Write-Log "Installation may have succeeded but registry not updated, or DisplayName mismatch" "WARNING"
        Write-Log "Hint: Check if the DisplayName parameter matches how the app appears in Add/Remove Programs" "WARNING"
        $InstallSuccess = $false
    }

    Write-Log "========================================="
}

## Final result
Write-Log "========================================="
Write-Log "Final Result:"

if ($InstallSuccess -eq $true) {
    Write-Log "SCRIPT: $ThisFileName | END | Installation of $AppName successful!" "SUCCESS"
    Exit 0
} else {
    Write-Log "SCRIPT: $ThisFileName | END | Installation of $AppName failed!" "ERROR"
    Exit 1
}